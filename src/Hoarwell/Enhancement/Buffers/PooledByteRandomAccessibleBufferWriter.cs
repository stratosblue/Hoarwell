// <Auto-Generated/>

#pragma warning disable CS1591

using System.Buffers;
using System.Diagnostics;

namespace Hoarwell.Enhancement.Buffers;

// base on https://github.com/dotnet/runtime/blob/release/8.0/src/libraries/Common/src/System/Text/Json/PooledByteBufferWriter.cs

/// <summary>
/// 基于 <see cref="ArrayPool{T}"/> 池化的 <inheritdoc cref="IRandomAccessibleBufferWriter{T}"/>
/// </summary>
public sealed class PooledByteRandomAccessibleBufferWriter : IRandomAccessibleBufferWriter<byte>, IDisposable
{
    // This class allows two possible configurations: if rentedBuffer is not null then
    // it can be used as an IBufferWriter and holds a buffer that should eventually be
    // returned to the shared pool. If rentedBuffer is null, then the instance is in a
    // cleared/disposed state and it must re-rent a buffer before it can be used again.
    private byte[]? _rentedBuffer;
    private int _index;

    private const int MinimumBufferSize = 256;

    // Value copied from Array.MaxLength in System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Array.cs.
    public const int MaximumBufferSize = 0X7FFFFFC7;

    /// <inheritdoc cref="PooledByteRandomAccessibleBufferWriter"/>
    public PooledByteRandomAccessibleBufferWriter(int initialCapacity)
    {
        Debug.Assert(initialCapacity > 0);

        _rentedBuffer = ArrayPool<byte>.Shared.Rent(initialCapacity);
        _index = 0;
    }

    /// <inheritdoc/>
    public ReadOnlyMemory<byte> WrittenMemory
    {
        get
        {
            Debug.Assert(_rentedBuffer != null);
            Debug.Assert(_index <= _rentedBuffer.Length);
            return _rentedBuffer.AsMemory(0, _index);
        }
    }

    /// <inheritdoc/>
    public int WrittenCount
    {
        get
        {
            Debug.Assert(_rentedBuffer != null);
            return _index;
        }
    }

    /// <inheritdoc/>
    public int Capacity
    {
        get
        {
            Debug.Assert(_rentedBuffer != null);
            return _rentedBuffer.Length;
        }
    }

    /// <inheritdoc/>
    public int FreeCapacity
    {
        get
        {
            Debug.Assert(_rentedBuffer != null);
            return _rentedBuffer.Length - _index;
        }
    }

    public void Clear()
    {
        ClearHelper();
    }

    public void ClearAndReturnBuffers()
    {
        Debug.Assert(_rentedBuffer != null);

        ClearHelper();
        byte[] toReturn = _rentedBuffer;
        _rentedBuffer = null;
        ArrayPool<byte>.Shared.Return(toReturn);
    }

    private void ClearHelper()
    {
        Debug.Assert(_rentedBuffer != null);
        Debug.Assert(_index <= _rentedBuffer.Length);

        _rentedBuffer.AsSpan(0, _index).Clear();
        _index = 0;
    }

    // Returns the rented buffer back to the pool
    public void Dispose()
    {
        if (_rentedBuffer == null)
        {
            return;
        }

        ClearHelper();
        byte[] toReturn = _rentedBuffer;
        _rentedBuffer = null;
        ArrayPool<byte>.Shared.Return(toReturn);
    }

    public void InitializeEmptyInstance(int initialCapacity)
    {
        Debug.Assert(initialCapacity > 0);
        Debug.Assert(_rentedBuffer is null);

        _rentedBuffer = ArrayPool<byte>.Shared.Rent(initialCapacity);
        _index = 0;
    }

    /// <inheritdoc/>
    public void Advance(int count)
    {
        Debug.Assert(_rentedBuffer != null);
        Debug.Assert(count >= 0);
        Debug.Assert(_index <= _rentedBuffer.Length - count);
        _index += count;
    }

    /// <inheritdoc/>
    public Memory<byte> GetMemory(int sizeHint = MinimumBufferSize)
    {
        CheckAndResizeBuffer(sizeHint);
        return _rentedBuffer.AsMemory(_index);
    }

    /// <inheritdoc/>
    public Span<byte> GetSpan(int sizeHint = MinimumBufferSize)
    {
        CheckAndResizeBuffer(sizeHint);
        return _rentedBuffer.AsSpan(_index);
    }

    #region RandomAccessible

    /// <inheritdoc/>
    public Memory<byte> GetMemory(in int offset, in int sizeHint)
    {
        Debug.Assert(_rentedBuffer != null);

        if (offset + sizeHint > _rentedBuffer.Length)
        {
            CheckAndResizeBuffer(offset + sizeHint - _index);
        }
        return _rentedBuffer.AsMemory(offset, sizeHint);
    }

    /// <inheritdoc/>
    public Span<byte> GetSpan(in int offset, in int sizeHint)
    {
        Debug.Assert(_rentedBuffer != null);

        if (offset + sizeHint > _rentedBuffer.Length)
        {
            CheckAndResizeBuffer(offset + sizeHint - _index);
        }
        return _rentedBuffer.AsSpan(offset, sizeHint);
    }

    #endregion RandomAccessible

    internal ValueTask WriteToStreamAsync(Stream destination, CancellationToken cancellationToken)
    {
        return destination.WriteAsync(WrittenMemory, cancellationToken);
    }

    internal void WriteToStream(Stream destination)
    {
        destination.Write(WrittenMemory.Span);
    }

    private void CheckAndResizeBuffer(int sizeHint)
    {
        Debug.Assert(_rentedBuffer != null);
        //Debug.Assert(sizeHint > 0);
        if (sizeHint < 1)
        {
            sizeHint = MinimumBufferSize;
        }

        int currentLength = _rentedBuffer.Length;
        int availableSpace = currentLength - _index;

        // If we've reached ~1GB written, grow to the maximum buffer
        // length to avoid incessant minimal growths causing perf issues.
        if (_index >= MaximumBufferSize / 2)
        {
            sizeHint = Math.Max(sizeHint, MaximumBufferSize - currentLength);
        }

        if (sizeHint > availableSpace)
        {
            int growBy = Math.Max(sizeHint, currentLength);

            int newSize = currentLength + growBy;

            if ((uint)newSize > MaximumBufferSize)
            {
                newSize = currentLength + sizeHint;
                if ((uint)newSize > MaximumBufferSize)
                {
                    throw new OutOfMemoryException($"the size \"{(uint)newSize}\" is too large");
                }
            }

            byte[] oldBuffer = _rentedBuffer;

            _rentedBuffer = ArrayPool<byte>.Shared.Rent(newSize);

            Debug.Assert(oldBuffer.Length >= _index);
            Debug.Assert(_rentedBuffer.Length >= _index);

            Span<byte> oldBufferAsSpan = oldBuffer.AsSpan(0, _index);
            oldBufferAsSpan.CopyTo(_rentedBuffer);
            oldBufferAsSpan.Clear();
            ArrayPool<byte>.Shared.Return(oldBuffer);
        }

        Debug.Assert(_rentedBuffer.Length - _index > 0);
        Debug.Assert(_rentedBuffer.Length - _index >= sizeHint);
    }
}


